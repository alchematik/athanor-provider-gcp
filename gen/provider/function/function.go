// Code generated by athanor-go.
// DO NOT EDIT.

package function

import (
	"context"
	"fmt"
	sdk "github.com/alchematik/athanor-go/sdk/provider/value"
	"github.com/alchematik/athanor-provider-gcp/gen/provider/identifier"
)

type Function struct {
	Identifier identifier.FunctionIdentifier
	Config     Config
	Attrs      Attrs
}

func (x Function) ToResourceValue() (sdk.Resource, error) {
	id := x.Identifier.ToValue()

	config := x.Config.ToValue()

	attrs := x.Attrs.ToValue()

	return sdk.Resource{
		Identifier: id,
		Config:     config,
		Attrs:      attrs,
	}, nil
}

type FunctionGetter interface {
	GetFunction(context.Context, identifier.FunctionIdentifier) (Function, error)
}

type FunctionCreator interface {
	CreateFunction(context.Context, identifier.FunctionIdentifier, Config) (Function, error)
}

type FunctionUpdator interface {
	UpdateFunction(context.Context, identifier.FunctionIdentifier, Config, []sdk.UpdateMaskField) (Function, error)
}

type FunctionDeleter interface {
	DeleteFunction(context.Context, identifier.FunctionIdentifier) error
}

type FunctionHandler struct {
	FunctionGetter  FunctionGetter
	FunctionCreator FunctionCreator
	FunctionUpdator FunctionUpdator
	FunctionDeleter FunctionDeleter

	CloseFunc func() error
}

func (h *FunctionHandler) GetResource(ctx context.Context, id sdk.Identifier) (sdk.Resource, error) {
	if h.FunctionGetter == nil {
		return sdk.Resource{}, fmt.Errorf("unimplemented")
	}

	idVal, err := identifier.ParseFunctionIdentifier(id)
	if err != nil {
		return sdk.Resource{}, err
	}

	r, err := h.FunctionGetter.GetFunction(ctx, idVal)
	if err != nil {
		return sdk.Resource{}, err
	}

	return r.ToResourceValue()
}

func (h *FunctionHandler) CreateResource(ctx context.Context, id sdk.Identifier, config any) (sdk.Resource, error) {
	if h.FunctionCreator == nil {
		return sdk.Resource{}, fmt.Errorf("unimplemented")
	}

	idVal, err := identifier.ParseFunctionIdentifier(id)
	if err != nil {
		return sdk.Resource{}, err
	}

	configVal, err := ParseConfig(config)
	if err != nil {
		return sdk.Resource{}, err
	}

	r, err := h.FunctionCreator.CreateFunction(ctx, idVal, configVal)
	if err != nil {
		return sdk.Resource{}, err
	}

	return r.ToResourceValue()
}

func (h *FunctionHandler) UpdateResource(ctx context.Context, id sdk.Identifier, config any, mask []sdk.UpdateMaskField) (sdk.Resource, error) {
	if h.FunctionUpdator == nil {
		return sdk.Resource{}, fmt.Errorf("unimplemented")
	}

	idVal, err := identifier.ParseFunctionIdentifier(id)
	if err != nil {
		return sdk.Resource{}, err
	}

	configVal, err := ParseConfig(config)
	if err != nil {
		return sdk.Resource{}, err
	}

	r, err := h.FunctionUpdator.UpdateFunction(ctx, idVal, configVal, mask)
	if err != nil {
		return sdk.Resource{}, err
	}

	return r.ToResourceValue()
}

func (h *FunctionHandler) DeleteResource(ctx context.Context, id sdk.Identifier) error {
	if h.FunctionDeleter == nil {
		return fmt.Errorf("unimplemented")
	}

	idVal, err := identifier.ParseFunctionIdentifier(id)
	if err != nil {
		return err
	}

	return h.FunctionDeleter.DeleteFunction(ctx, idVal)
}

func (h *FunctionHandler) Close() error {
	if h.CloseFunc != nil {
		return h.CloseFunc()
	}

	return nil
}

type Attrs struct {
	Url string
}

func (x Attrs) ToValue() any {
	return map[string]any{
		"url": sdk.ToType[any](x.Url),
	}
}

func ParseAttrs(v any) (Attrs, error) {
	m, err := sdk.Map[any](v)
	if err != nil {
		return Attrs{}, fmt.Errorf("error parsing attrs: %v", err)
	}

	url, err := sdk.String(m["url"])
	if err != nil {
		return Attrs{}, fmt.Errorf("error parsing attrs for function: %v", err)
	}

	return Attrs{
		Url: url,
	}, nil
}

type BuildConfig struct {
	Entrypoint string
	Runtime    string
	Source     sdk.File
}

func (x BuildConfig) ToValue() any {
	return map[string]any{
		"entrypoint": sdk.ToType[any](x.Entrypoint),
		"runtime":    sdk.ToType[any](x.Runtime),
		"source":     sdk.ToType[any](x.Source),
	}
}

func ParseBuildConfig(v any) (BuildConfig, error) {
	m, err := sdk.Map[any](v)
	if err != nil {
		return BuildConfig{}, fmt.Errorf("error parsing build_config: %v", err)
	}

	entrypoint, err := sdk.String(m["entrypoint"])
	if err != nil {
		return BuildConfig{}, fmt.Errorf("error parsing build_config for function: %v", err)
	}
	runtime, err := sdk.String(m["runtime"])
	if err != nil {
		return BuildConfig{}, fmt.Errorf("error parsing build_config for function: %v", err)
	}
	source, err := sdk.ParseFile(m["source"])
	if err != nil {
		return BuildConfig{}, fmt.Errorf("error parsing build_config for function: %v", err)
	}

	return BuildConfig{
		Entrypoint: entrypoint,
		Runtime:    runtime,
		Source:     source,
	}, nil
}

type Config struct {
	BuildConfig BuildConfig
	Description string
	Labels      map[string]string
}

func (x Config) ToValue() any {
	return map[string]any{
		"build_config": sdk.ToType[any](x.BuildConfig),
		"description":  sdk.ToType[any](x.Description),
		"labels":       sdk.ToType[string](x.Labels),
	}
}

func ParseConfig(v any) (Config, error) {
	m, err := sdk.Map[any](v)
	if err != nil {
		return Config{}, fmt.Errorf("error parsing config: %v", err)
	}

	build_config, err := ParseBuildConfig(m["build_config"])
	if err != nil {
		return Config{}, fmt.Errorf("error parsing config for function: %v", err)
	}
	description, err := sdk.String(m["description"])
	if err != nil {
		return Config{}, fmt.Errorf("error parsing config for function: %v", err)
	}
	labels, err := sdk.Map[string](m["labels"])
	if err != nil {
		return Config{}, fmt.Errorf("error parsing config for function: %v", err)
	}

	return Config{
		BuildConfig: build_config,
		Description: description,
		Labels:      labels,
	}, nil
}
